import pretty_midi
import pypianoroll
import numpy as np
import os

import random
from utils import save_txt_list, get_start_end_frame
from plot_functions import plot_curve_pitches

def select_note_from_group(group, logic_type):
    """
    Given a group of notes, it selects one based on the defined logic type.
    It can work in three ways:
    logic_type = 0
      In this mode, the lowest pitch in a chord is always selected
    logic type = 1
      In this mode, the middle pitch in a chord is always selected. If there is
      no clear middle item, a random choice between the two most central ones
      is made
    logic_type = 2
      In this mode, the highest pitch in a chord is always selected
    
    Parameters
    ----------
    group : list
        A list with notes, generated by the midi_postprocessing function
    logic_type : int
        The algorithm used to convert from polyphonic to monophonic
    Returns
    -------
    list
        The selected note
    """
    assert logic_type >= 0 and logic_type <= 2, 'The provided logic type is invalid'

    selected_idx = -1

    notes_indices = list(range(0,len(group)))
    
    if logic_type == 0: # select min index
        selected_idx = 0
    elif logic_type == 1: # select middle index (if possible)
        middle = float(len(group)) / 2 
        if middle % 2 == 0 or len(group) == 2: # if there's a doubt, select a random one
            possible_items = [int(middle), int(middle-1)]
            selected_idx = random.choice(possible_items)
        else: # if there's a clear middle item, select it
            selected_idx = int(middle - .5)
    elif logic_type == 2: # select max index
        selected_idx = len(group) - 1


    #HANDLE: case in which in each group there are only 2 notes: 1 will be the melody and 1 the harmony.
    harmony_notes = [group[i] for i in notes_indices if i != selected_idx]
    motiv_note = group[selected_idx]


    return motiv_note, harmony_notes



def postprocess_motiv_harmony(input_list, 
                              L=5,
                              max_dur = 2):
    """
    For each note, the function controls if the next L notes start before its end.
    If yes, the next tone belongs to the harmony track.

    Args:
        input_list (list): input list of midi notes
        L (int): num of next notes to be checked. Defaults to 5.
        max_dur (int, optional): maximum duration in seconds allowed for a single note. Defaults to 2.

    Returns:
        motiv_list (list): list of notes belonging to the motiv
        additional_harmony_list (list): list of notes belonging to the harmony
    """

    #order values by start time
    input_list = sorted(input_list, key=lambda x: (x[0], x[1]))   

    len_input_list = len(input_list)
    motiv_list = []
    additional_harmony_list = []

    #list used to take track of the deleted notes
    notes_indices_list = list(range(0,len_input_list))

    pitch_list = list(map(lambda x:x[2], input_list))
    avg_pitch = np.round(np.average(pitch_list))
    std_pitch = np.round(np.std(pitch_list))
    low_limit_pitch = int(avg_pitch-std_pitch)

    i=0
    while(i < len_input_list):
        
        #if the current note has not been processed yet
        if (i in notes_indices_list):

            curr_note = input_list[i]
            curr_start = curr_note[0]
            curr_end = curr_note[1]
            curr_pitch = curr_note[2]

            ##filter if the pitch is lower than the limit bound
            if(curr_pitch < low_limit_pitch):
                additional_harmony_list.append(curr_note)
                i+=1
                continue                

            motiv_list.append(curr_note)

            try:
                j = 0
                while(j < L):
                    next_idx = i+j+1
                    next_note = input_list[next_idx]
                    next_start = next_note[0]

                    if(next_start < curr_end):
                        additional_harmony_list.append(next_note)
                        notes_indices_list.remove(next_idx)

                    j+=1
            except:
                #if we are out of range, we decrement the nÂ° of next notes to be checked
                L = L-1
                continue
                
        i+=1

    return motiv_list, additional_harmony_list


def mono_to_motiv_harmony(input_midi_file, Fs_msp, save_path=""):
    """
    Given a 1-track midi file, the function splits it into melody and chords

    Args:
        input_midi_file (PrettyMIDI): midi file composed of 1 track
        Fs_msp (int): sample rate
        save_path (str, optional): path where the output file is saved. Defaults to "".

    Returns:
        out_midi(PrettyMIDI): midi file composed of a motiv track and a harmony track.
    """

    midi_list = []

    #create midi list event
    for instrument in input_midi_file.instruments:
        for note in instrument.notes:
            start = note.start 
            end = note.end 
            pitch = note.pitch
            midi_list.append([start, end, pitch])   

    # sort midi list by start time, and by pitch
    midi_list = sorted(midi_list, key=lambda x: (x[0], x[2])) 

    # group by start time
    values = sorted(set(map(lambda x:x[0], midi_list)))

    #each element of the list is a group of note with the same starting point
    group_by_start_time = [[y for y in midi_list if y[0]==x] for x in values]       

    selected_notes = [] 
    selected_harmony_groups = []

    #motiv/harmony split
    for group in group_by_start_time:
        #if there is polyphony (group dimension > 1), we split the notes into note and harmony, otherwise we have only the melody.
        if len(group) > 1:
            note, harmony = select_note_from_group(group, logic_type=2)  #choose the highest note
            selected_harmony_groups.append(harmony)
        else:
            note = group[0]

        selected_notes.append(note)

    #postprocessing
    motiv_list, additional_harmony_list = postprocess_motiv_harmony(selected_notes)

    #add the notes selected after preprocessing to the harmony
    selected_harmony_groups.append(additional_harmony_list)

    #flatten harmony groups into a list of single note items
    selected_harmony_notes = [item for sublist in selected_harmony_groups for item in sublist]

    #time -> frame
    frames_list = midi_list_to_frames_list(motiv_list, Fs_msp)

    # write resulting midi file out
    out_midi = pretty_midi.PrettyMIDI()

    #create melody and harmony instruments
    melody_program = pretty_midi.instrument_name_to_program('Violin')
    harmony_program = pretty_midi.instrument_name_to_program('Acoustic grand piano')

    melody = pretty_midi.Instrument(program=melody_program, name="Motiv")
    harmony = pretty_midi.Instrument(program=harmony_program, name="Harmony")
    
    for note in motiv_list:
        pretty_midi_note = pretty_midi.Note(velocity=90, pitch=note[2], start=note[0], end=note[1])
        melody.notes.append(pretty_midi_note)

    for note in selected_harmony_notes:
        pretty_midi_note = pretty_midi.Note(velocity=90, pitch=note[2], start=note[0], end=note[1])
        harmony.notes.append(pretty_midi_note)

    save_flag = True

    out_path_file = os.path.join(save_path,"motiv.mid")

    #save melody and harmony separately
    if(save_flag):
        melody_midi = pretty_midi.PrettyMIDI()
        melody_midi.instruments.append(melody)
        out_path_file = os.path.join(save_path,"motiv.mid")
        melody_midi.write(out_path_file)

        harmony_midi = pretty_midi.PrettyMIDI()
        harmony_midi.instruments.append(harmony)
        out_path_file = os.path.join(save_path,"harmony.mid")
        harmony_midi.write(out_path_file)

    out_midi.instruments.append(melody)
    out_midi.instruments.append(harmony)

    return out_midi


def midi_list_to_frames_list(input_midi_list, Fs_msp):

    """
    This functions convert an input midi list from the time domain to the frame domain

    Args:
        input_midi_list (list): input list of midi notes in the time domain
        Fs_msp (int): sample rate
    Returns:
        frame_list (np.ndarray):  array of midi notes in the frame domain
    """

    dur = input_midi_list[-1][1]

    time_frames = (np.arange(0, dur+1, 1/Fs_msp, dtype=float))
    frames_list = np.zeros(shape=len(time_frames), dtype=int)

    for midi_note in input_midi_list:
        start_min, end_min = get_start_end_frame(midi_note, Fs=Fs_msp)
        frames_list[start_min:end_min] = midi_note[2]
    
    return frames_list


def multi2mono_midifile(multitrack, save_path=""):
    """
    Given a multi-track pypiano object, this function returns its mono-track version

    Args:
        multitrack (pypianoroll.Multitrack): multitrack object of the input file
        save_path (str, optional): output folder. Defaults to "".

    Returns:
        midi_data (PrettyMidi): midi object of the mono-track compressed version of the input file.
    """

    n_tracks = len(multitrack.tracks)
    len_piano_roll = multitrack[0].pianoroll.shape

    #create monophonic midi file first
    mono_piano_roll = np.zeros(shape = len_piano_roll)

    #compress tracks into one mono track
    i=0
    while(i<n_tracks):

        track = multitrack.tracks[i]

        #sum pianoroll only if it is not a drum track
        if(track.is_drum == False):
            mono_piano_roll[:, :] += track.pianoroll[:, :]   
        i+=1    

    mono_track = pypianoroll.StandardTrack(name = "Mono", program = 1, is_drum=False, pianoroll=mono_piano_roll)

    #overwrite multitrack with the new single-track pianoroll
    multitrack.tracks = [mono_track]

    #convert pypianoroll -> midi 
    out_filename = "mono.mid" 
    out_path = os.path.join(save_path, out_filename)
    multitrack.write(out_path) 
    midi_data = pretty_midi.PrettyMIDI(out_path)

    return midi_data


def split_motiv_harmony(filename, output_folder):
    
    """
    Given a midifile. this function creates a file with 2 tracks, one for the harmony and one for the motiv.

    Args:
        filename (str): pathname of the input midi file
        output_folder (str): pathname of the output folder

    """

    #load pypianoroll
    multitrack  = pypianoroll.read(filename)   

    #compress all tracks into a single score
    mono_midi = multi2mono_midifile(multitrack, save_path=output_folder)

    #split score into motiv and harmony
    out_midi = mono_to_motiv_harmony(mono_midi, Fs_msp=10, save_path=output_folder)

    
    #save
    outpath_split_midifile = os.path.join(output_folder, "motiv_harmony_split.mid")
    out_midi.write(outpath_split_midifile)

    #plot
    plot_curve_pitches(outpath_split_midifile)