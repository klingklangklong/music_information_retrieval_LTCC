
import pretty_midi
import pypianoroll
import numpy as np

import random


import yaml
from yaml.loader import SafeLoader

from utils import save_txt_list, get_start_end_frame
from plot_functions import plot_curve_pitches


###############################################
#Load variables from .yml file

yaml_path = "global.yaml"
with open(yaml_path) as f: # load yaml
    global_var = yaml.load(f, Loader=SafeLoader)

Fs = Fs_midi = Fs_symb = global_var["Fs"]
Fs_msp = global_var["Fs_msp"]
n_pitches = global_var["n_pitches"]
lowest_pitch = global_var["lowest_pitch"]
num_midi_notes = global_var["num_midi_notes"]
num_steps = global_var["num_steps"]
keys = global_var["keys"]
keys_ordered = global_var["keys_ordered"]

###############################################




#Load variables from .yml file

yaml_path = "global.yaml"
with open(yaml_path) as f: # load yaml
    global_var = yaml.load(f, Loader=SafeLoader)

Fs = Fs_midi = Fs_symb = global_var["Fs"]
Fs_msp = global_var["Fs_msp"]
n_pitches = global_var["n_pitches"]
lowest_pitch = global_var["lowest_pitch"]
num_midi_notes = global_var["num_midi_notes"]
num_steps = global_var["num_steps"]
keys = global_var["keys"]
keys_ordered = global_var["keys_ordered"]




def select_note_from_group(group, logic_type):
    """
    Given a group of notes, it selects one based on the defined logic type.
    It can work in three ways:
    logic_type = 0
      In this mode, the lowest pitch in a chord is always selected
    logic type = 1
      In this mode, the middle pitch in a chord is always selected. If there is
      no clear middle item, a random choice between the two most central ones
      is made
    logic_type = 2
      In this mode, the highest pitch in a chord is always selected
    
    Parameters
    ----------
    group : list
        A list with notes, generated by the midi_postprocessing function
    logic_type : int
        The algorithm used to convert from polyphonic to monophonic
    Returns
    -------
    list
        The selected note
    """
    assert logic_type >= 0 and logic_type <= 2, 'The provided logic type is invalid'

    selected_idx = -1

    notes_indices = list(range(0,len(group)))
    

    if logic_type == 0: # select min index
        selected_idx = 0
    elif logic_type == 1: # select middle index (if possible)
        middle = float(len(group)) / 2 
        if middle % 2 == 0 or len(group) == 2: # if there's a doubt, select a random one
            possible_items = [int(middle), int(middle-1)]
            selected_idx = random.choice(possible_items)
        else: # if there's a clear middle item, select it
            selected_idx = int(middle - .5)
    elif logic_type == 2: # select max index
        selected_idx = len(group) - 1

    #print("Selected idx: ", selected_idx)
    #print("Indices: ", notes_indices)


    #HANDLE: case in which in each group there are only 2 notes: 1 will be the melody and 1 the harmony.
    
    harmony_notes = [group[i] for i in notes_indices if i != selected_idx]
    
    motiv_note = group[selected_idx]


    return motiv_note, harmony_notes



def postprocess_motiv_harmony(input_list, 
                              L=5,
                              max_dur = 2):

    """
    For each note, it controls if the next L notes start before its end.
    If yes, the next tone belongs to the harmony track.

    L = num of next notes to be checked
    max_dur = 2  maximum duration in seconds allowed for a single note
    """
    #order values by start time
    input_list = sorted(input_list, key=lambda x: (x[0], x[1]))   

    len_input_list = len(input_list)
    motiv_list = []
    additional_harmony_list = []

    #list used to take track of the deleted notes
    notes_indices_list = list(range(0,len_input_list))

    pitch_list = list(map(lambda x:x[2], input_list))
    avg_pitch = np.round(np.average(pitch_list))
    std_pitch = np.round(np.std(pitch_list))
    low_limit_pitch = int(avg_pitch-std_pitch)
    print(low_limit_pitch)




    i=0
    while(i < len_input_list):
        
        #if the current note has not been processed yet
        if (i in notes_indices_list):

            curr_note = input_list[i]
            curr_start = curr_note[0]
            curr_end = curr_note[1]
            curr_pitch = curr_note[2]

            ##filter if the pitch is lower than the limit bound
            if(curr_pitch < low_limit_pitch):
                additional_harmony_list.append(curr_note)
                i+=1
                continue                

            ##filter if the duration is higher than max_dur
            #if((curr_end - curr_start) > max_dur):
            #    additional_harmony_list.append(curr_note)
            #    i+=1
            #    continue

            motiv_list.append(curr_note)

            try:
                j = 0
                while(j < L):
                    next_idx = i+j+1
                    next_note = input_list[next_idx]
                    next_start = next_note[0]

                    if(next_start < curr_end):
                        additional_harmony_list.append(next_note)
                        notes_indices_list.remove(next_idx)

                    j+=1
            except:
                #if we are out of range, we decrement the nÂ° of next notes to be checked
                L = L-1
                #print("Out of range. Decrement L = ", L)
                continue
                


        i+=1

    return motiv_list, additional_harmony_list




def mono_to_motiv_harmony(input_midi_file, Fs_msp, save_path=""):

    """
    Given a 1-track midi file, it splits it into melody and chords
    """

    midi_list = []

    #create midi list event
    for instrument in input_midi_file.instruments:
        for note in instrument.notes:
            start = note.start 
            end = note.end 
            pitch = note.pitch
            midi_list.append([start, end, pitch])   


    # sort midi list by start time, and by pitch
    midi_list = sorted(midi_list, key=lambda x: (x[0], x[2])) 

    # group by start time
    values = sorted(set(map(lambda x:x[0], midi_list)))

    #each element of the list is a group of note with the same starting point
    group_by_start_time = [[y for y in midi_list if y[0]==x] for x in values]       

    selected_notes = [] 
    selected_harmony_groups = []


    #motiv/harmony split
    for group in group_by_start_time:
        #if there is polyphony (group dimension > 1), we split the notes into note and harmony, otherwise we have only the melody.
        if len(group) > 1:
            note, harmony = select_note_from_group(group, logic_type=2)  #choose the highest note
            selected_harmony_groups.append(harmony)
        else:
            note = group[0]

        selected_notes.append(note)


    #postprocessing
    motiv_list, additional_harmony_list = postprocess_motiv_harmony(selected_notes)

    #add the notes selected after preprocessing to the harmony
    selected_harmony_groups.append(additional_harmony_list)

    #flatten harmony groups into a list of single note items
    selected_harmony_notes = [item for sublist in selected_harmony_groups for item in sublist]


    #midi_list -> midi_frame
    #time -> frame
    #ToDo: function!!
    print("motiv list: ", motiv_list)
    frames_list = midi_list_to_frames_list(motiv_list, Fs_msp)

    save_txt_list(frames_list, filename = "melody.txt")


    # write resulting midi file out
    out_midi = pretty_midi.PrettyMIDI()


    #create melody and harmony instruments
    melody_program = pretty_midi.instrument_name_to_program('Violin')
    harmony_program = pretty_midi.instrument_name_to_program('Acoustic grand piano')

    melody = pretty_midi.Instrument(program=melody_program, name="Motiv")
    harmony = pretty_midi.Instrument(program=harmony_program, name="Harmony")
    
    for note in motiv_list:
        pretty_midi_note = pretty_midi.Note(velocity=90, pitch=note[2], start=note[0], end=note[1])
        melody.notes.append(pretty_midi_note)

    for note in selected_harmony_notes:
        pretty_midi_note = pretty_midi.Note(velocity=90, pitch=note[2], start=note[0], end=note[1])
        harmony.notes.append(pretty_midi_note)

    save_flag = True

    #save melody and harmony separately
    if(save_flag):
        melody_midi = pretty_midi.PrettyMIDI()
        melody_midi.instruments.append(melody)
        melody_midi.write(save_path + "/" + "motiv.mid")

        harmony_midi = pretty_midi.PrettyMIDI()
        harmony_midi.instruments.append(harmony)
        harmony_midi.write(save_path + "/" + "harmony.mid")

    out_midi.instruments.append(melody)
    out_midi.instruments.append(harmony)

    return out_midi


def midi_list_to_frames_list(input_midi_list, Fs_msp):

    dur = input_midi_list[-1][1]

    #ToDo: parametrize Fs
    time_frames = (np.arange(0, dur+1, 1/Fs_msp, dtype=float))
    frames_list = np.zeros(shape=len(time_frames), dtype=int)

    for midi_note in input_midi_list:

        start_min, end_min = get_start_end_frame(midi_note, Fs=Fs_msp)
        frames_list[start_min:end_min] = midi_note[2]
    

    return frames_list


def multi2mono_midifile(multitrack, save_path=""):

    """
    Given a multi-track pypiano object, it returns its mono-track version
    """

    n_tracks = len(multitrack.tracks)
    len_piano_roll = multitrack[0].pianoroll.shape

    #create monophonic midi file first
    mono_piano_roll = np.zeros(shape = len_piano_roll)

    #compress tracks into one mono track
    i=0
    while(i<n_tracks):

        track = multitrack.tracks[i]

        #sum pianoroll only if it is not a drum track
        if(track.is_drum == False):
            mono_piano_roll[:, :] += track.pianoroll[:, :]   
        i+=1    

    mono_track = pypianoroll.StandardTrack(name = "Mono", program = 1, is_drum=False, pianoroll=mono_piano_roll)

    #set global tempo (usefull?)
    #mono_track.tempo = np.ones((len_piano_roll[0],1)) * global_bpm  

    #overwrite multitrack with the new single-track pianoroll
    multitrack.tracks = [mono_track]

    #convert pypianoroll -> midi 
    out_filename = "mono.midi" 
    multitrack.write(save_path + "/" + out_filename) 
    midi_data = pretty_midi.PrettyMIDI(save_path + "/" + out_filename)

    return midi_data


def split_motiv_harmony(filename):

    #load pypianoroll
    multitrack  = pypianoroll.read(filename)   

    #compress all tracks into a single score
    mono_midi = multi2mono_midifile(multitrack)

    #split score into motiv and harmony
    out_midi = mono_to_motiv_harmony(mono_midi, Fs_msp=10)

    #save
    out_midi.write("split.mid")

    #plot
    plot_curve_pitches("split.mid")